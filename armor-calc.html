<!DOCTYPE html>
<html lang="ja">
<head>

    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="shortcut icon" href="favicon-renma.ico">
    <link rel="apple-touch-icon" href="apple-touch-icon-renma.png">
    <link rel="icon" type="image/png" href="web-app-manifest-192x192-renma.png">
    <title>練磨(防具)自動選定ツール</title> <!-- Created by じぇ -->

    <style>
        /* --- 全体 --- */
        body {
            background-color: #2A2A2A;
            color: #eee;
            font-family: 'Meiryo', sans-serif;
            padding: 20px;
            margin: 0;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        /* --- ヘッダー --- */
        header { 
            text-align: center; 
            margin-bottom: 20px; 
        }

        h1 { 
            color: #50b4f0; 
            margin: 0;
        }

        /* --- グローバルコンテナ --- */
        .main-container {
            width: 100%;
            max-width: 1600px;
        }
        
        /* --- ファイル入力 --- */
        .file-input-container {
            border-radius: 8px;
            margin-bottom: 20px;
            box-sizing: border-box;
            text-align: center;
        }
        #file-status { 
            margin-top: 10px; 
            color: #ffd700; 
        }

        /* --- キャラクターグリッド (1列・5行レイアウト) --- */
        .character-grid {
            display: flex;
            flex-direction: column;
            gap: 20px;
            width: 100%;
        }

        /* --- キャラクターコンテナ --- */
        .character-container {
            background-color: #383838;
            border: 1px solid #555;
            border-radius: 8px;
            padding: 20px 20px;
        }
        
        h2 {
            color: #c0c0ff;
            margin: 0 0 15px 0;
            border-bottom: 2px solid #555;
            padding-bottom: 8px;
            margin-bottom: 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: 10px; /* Added gap */
        }

        .series-select {
            background-color: #444;
            color: #eee;
            border: 1px solid #777;
            border-radius: 4px;
            padding: 0 6px;
            font-size: 16px;
            margin-left: 10px;
            height: 30px;
            box-sizing: border-box;
        }
        
        .nav-buttons {
            display: flex;
            gap: 6px;
            margin-left: auto; /* Pushes the buttons to the right */
        }

        .nav-button {
            background-color: #555;
            color: #eee;
            border: 1px solid #777;
            padding: 4px 8px;
            cursor: pointer;
            font-size: 12px;
            border-radius: 3px;
            transition: background-color 0.2s;
        }

        .nav-button:hover {
            background-color: #666;
        }

        .nav-button:active {
            background-color: #444;
        }

        .nav-button:disabled {
            background-color: #333;
            color: #666;
            cursor: default;
            opacity: 0.5;
        }

        /* --- フォームの横並びコンテナ --- */
        .form-horizontal-row {
            display: flex;
            align-items: flex-start;
            gap: 20px;
            margin-bottom: 20px;
        }

        /* --- フォームスタイル --- */
        .form-section {
            padding: 15px;
            border: 1px solid #444;
            border-radius: 5px;
        }
        .form-section legend {
            font-weight: bold;
            color: #98fb98;
            padding: 0 5px;
        }
        
        .form-type .form-group {
            display: flex;
            gap: 25px;
        }

        .form-conditions {
            flex-grow: 1;
        }
        .conditions-wrapper {
            display: flex;
            flex-wrap: wrap;
            gap: 10px 20px;
        }
        
        .form-group label {
            display: inline-flex;
            align-items: center;
            gap: 5px;
            cursor: pointer;
        }

        /* --- 結果表示 --- */
        .result-area {
            background-color: #2a2a2a;
            padding: 15px;
            border-radius: 5px;
            border: 1px dashed #777;
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: 20px;
        }
        
        .result-details {
            flex-grow: 1;
        }
        
        .result-table {
            width: 100%;
            border-collapse: collapse;
            table-layout: fixed;
        }
        .result-table td {
            padding: 8px;
            text-align: left;
            vertical-align: middle;
            border-bottom: 1px solid #3a3a3a;
        }
        .result-table tr:last-child td {
            border-bottom: none;
        }
        
        .col-heading { width: 7%; }
        .col-armor   { width: 33%; }
        .col-ability { width: 37%; }
        .col-value   { width: 23%; }
        
        .data-label {
            display: inline-block;
            text-align: right;
            margin-right: 8px;
            color: #a0a0a0;
        }

        .heading-text { color: #c0c0ff; font-weight: bold; }
        .armor-text   { color: #98fb98; }
        .ability-text { color: #ccc; }
        .value-text   { color: #ffd700; font-weight: bold; }
        
        .total-container {
            padding-left: 20px;
            border-left: 1px solid #555;
            white-space: nowrap;
            text-align: right;
        }

        .total-container .total-row {
            display: flex;
            justify-content: space-between;
            align-items: baseline;
            gap: 15px;
        }

        .total-container .label {
            font-size: 16px;
            color: #a0a0a0;
        }

        .total-container .value {
             font-weight: bold;
             font-size: 24px;
             color: #ffd700;
        }

        .total-container .final-total .label,
        .total-container .final-total .value {
            color: red; /* 合計の色 */
        }
        
        .global-controls {
            text-align: center;
            margin-top: 20px;
        }

        .calculate-button {
            background-color: #f0506e;
            color: #fff;
            border: none;
            padding: 15px 30px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 20px;
            font-weight: bold;
            transition: background-color 0.2s, transform 0.2s, box-shadow 0.2s;
        }

        .calculate-button:hover:not(:disabled) {
            background-color: #c8405a;
        }

        .calculate-button:active:not(:disabled) {
            transform: translateY(0);
        }

        .calculate-button:disabled {
            background-color: #555;
            color: #888;
            cursor: not-allowed;
        }

        /* 拡大縮小ボタンのスタイル - absolute positioned to not scroll */
        .zoom-buttons {
            position: absolute;
            top: 15px;
            right: 15px;
            display: flex;
            flex-direction: column;
            gap: 5px;
            z-index: 1000;
        }

        .zoom-buttons button {
            padding: 5px 10px;
            font-size: 14px;
            cursor: pointer;
        }

        a:link { 
            color: #1D9BF0; 
            text-decoration: underline; 
        }

        a:visited { 
            color: #7755FF; 
            text-decoration: underline; 
        }

        a:hover { 
            color: #0CFF57; 
        }

        a:active { 
            color: #FF0000; 
            text-decoration: underline; 
        }

        footer {
            width: 100%;
            border-top: 1px solid #eee;
            padding-top: 10px;
            font-size: 12pt;
            margin-top: 40px;
        }

        .bottom {
            margin-top: 20px;
            font-size: 16pt;
            line-height: 2;
            text-align: center;
        }

        /* --- レスポンシブデザイン --- */

        /* 中サイズ画面 (幅992px以下) */
        @media (max-width: 992px) {
            .result-table tr {
                display: block;
                padding: 10px 0;
                border-bottom: 1px solid #3a3a3a;
            }
            .result-table tr:last-child {
                border-bottom: none;
                padding-bottom: 0;
            }
            .result-table td {
                display: block;
                width: 100%;
                border-bottom: none;
                padding: 5px 0;
            }

            /* 固定幅を解除 */
            .col-heading, .col-armor, .col-ability, .col-value {
                width: auto;
            }
            .data-label {
                width: 90px;
            }
        }

        /* 小サイズ画面 (幅768px以下) */
        @media (max-width: 768px) {
            /* 結果表示エリア全体を縦並びにする */
            .result-area {
                flex-direction: column;
                align-items: stretch;
            }
            
            /* 合計値コンテナを下に移動させるための調整 */
            .total-container {
                border-left: none;
                border-top: 1px solid #555;
                padding-left: 0;
                padding-top: 15px;
                margin-top: 15px;
                text-align: right;
            }
            .total-container .total-row {
                justify-content: flex-end;
            }
        }

        /* ---【今回追加】画面幅480px以下のためのスタイル --- */
        @media (max-width: 480px) {
            .form-horizontal-row {
                flex-direction: column; /* アビリティと条件のセクションを縦積みにする */
                align-items: stretch;   /* 幅を親要素に合わせる */
            }
        }

    /* ハンバーガーメニューのスタイル */
    .hamburger {
      cursor: pointer;
      margin-left: -5px;
      margin-right: 10px;
      user-select: none;
      color: #eee;
      display: inline-block;
    }
    
    .hamburger:hover {
      color: #2A99E6;
    }

    .side-menu {
      position: fixed;
      top: 0;
      left: -320px;
      width: 320px;
      min-height: 100vh;
      height: 100%;
      text-align: left;
      background-color: #242424;
      border-right: 1px solid #555;
      transition: left 0.3s ease;
      z-index: 1001;
      padding: 20px;
      box-sizing: border-box;
      overflow-y: auto;
      overscroll-behavior: contain;
    }

    .side-menu.open {
      left: 0;
    }

    .menu-overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      min-width: 100vw;
      min-height: 100vh;
      background-color: rgba(0, 0, 0, 0.5);
      z-index: 999;
      opacity: 0;
      visibility: hidden;
      transition: opacity 0.3s, visibility 0.3s;
    }

    .menu-overlay.open {
      opacity: 1;
      visibility: visible;
    }

    .menu-close {
      position: absolute;
      top: 20px;
      right: 20px;
      font-size: 24px;
      cursor: pointer;
      color: #eee;
      user-select: none;
    }

    .menu-close:hover {
      color: #ff6b6b;
    }

    .menu-title {
      font-size: 18px;
      font-weight: bold;
      text-align: left;
      margin-bottom: 10px;
      color: #FF6E3D;
    }

    .menu-item {
      font-size: 18px;
      text-align: left;
      display: inline-block;
      padding: 6px 0;
      color: #eee;
      text-decoration: none;
    }

    .menu-item:hover {
      color: #0CFF57;
    }

    .menu-item:last-child {
      border-bottom: none;
    }

    .menu-spacer {
      height: 30px;
    }

   .toggle-button {
      cursor: pointer;
      color: #7755FF;
      text-decoration: underline;
      font-size: 18px;
      text-align: left;
      display: block;
      padding: 6px 0;
      user-select: none;
    }

    .toggle-button:hover {
      color: #0CFF57;
      text-decoration: underline;
    }

    #linkList {
      display: none;
      color: #7755FF;
    }

    #linkList1 {
      font-size: 18px;
      text-align: left;
      padding-bottom: 6px;
      display: none;
      color: #7755FF;
    }

    #linkList2 {
      font-size: 18px;
      text-align: left;
      display: none;
      color: #7755FF;
    }

    #linkList a {
      display: inline-block;
      text-decoration: none;
      color: #7755FF;
    }

    #linkList a:visited {
      color: #7755FF;
      text-decoration: underline;
    }

    #linkList a:hover {
      text-decoration: underline;
      color: #0CFF57;
    }

    #linkList a:active {
      color: #FF0000;
      text-decoration: underline;
    }
    
    /* --- renma-armor.html風のボタンスタイル --- */

    /* 共通クラス */
    .styled-form-group {
        display: flex;
        align-items: center;
        flex-wrap: wrap; /* 条件チェックボックスが折り返せるように */
        gap: 5px 10px;   /* ボタン間の隙間 */
    }

    /* 元のラジオボタンとチェックボックスを非表示にする */
    .styled-form-group input[type="radio"],
    .styled-form-group input[type="checkbox"] {
        display: none;
    }

    /* labelをボタンのようにスタイリング */
    .styled-form-group label {
        padding: 5px 15px;
        border: 1px solid #777;
        border-radius: 20px; /* pill型デザインの角丸 */
        cursor: pointer;
        background-color: #555;
        color: white;
        transition: all 0.2s;
        margin: 0; /* 元のlabelスタイルを上書き */
        user-select: none;
    }

    /* 選択された際のスタイル(デフォルト) */
    .styled-form-group input[type="radio"]:checked + label,
    .styled-form-group input[type="checkbox"]:checked + label {
        background-color: #007bff;
        color: white;
        border-color: #007bff;
    }

    /* アビリティ選択ボタンの折り返しを禁止 */
    .form-type .styled-form-group {
        flex-wrap: nowrap;
    }

    /* --- 特定の条件ボタンの色を変更 --- */
    .styled-form-group input[value="HP満タン時"]:checked + label {
        background-color: forestgreen;
        border-color: forestgreen;
    }
    .styled-form-group input[value="瀕死時"]:checked + label {
        background-color: forestgreen;
        border-color: forestgreen;
    }
    .styled-form-group input[value="カウンター"]:checked + label {
        background-color: forestgreen;
        border-color: forestgreen;
    }
    .styled-form-group input[value="熱"]:checked + label {
        background-color: red;
        border-color: red;
    }
    .styled-form-group input[value="冷"]:checked + label {
        background-color: dodgerblue;
        border-color: dodgerblue;
    }
    .styled-form-group input[value="雷"]:checked + label {
        background-color: darkorange;
        border-color: darkorange;
    }
    .styled-form-group input[value="陽"]:checked + label {
        background-color: orangered;
        border-color: orangered;
    }
    .styled-form-group input[value="陰"]:checked + label {
        background-color: darkorchid;
        border-color: darkorchid;
    }

    </style>
</head>
<body>

  <div class="menu-overlay" id="menuOverlay" onclick="closeMenu()"></div>

  <div class="side-menu" id="sideMenu">
    <div class="menu-title">リユニのWeb版いろいろ</div>
    <a class="menu-item" href="kiokucalc.html">記憶再戦時間計算</a><br>
    <a class="menu-item" href="kiokucalc2.html">記憶再戦回数計算</a><br>
    </br>
    <a class="menu-item" href="ikuseicalc.html">育成効率比較ツール</a><br>
    <a class="menu-item" href="raidcalc.html">レイド周回効率比較ツール</a><br>
    </br>
    <a class="menu-item" href="renma-armor.html">練磨(防具)統合ツール</a><br>
    <span class="toggle-button" data-target="linkList3">練磨(防具)個別ページ</span>
    <div id="linkList3">
      ├ <a class="menu-item" href="armor-renma.html">練磨(防具)リスト</a><br>
      ├ <a class="menu-item" href="armor-top5.html">練磨(防具)TOP5確認</a><br>
      └ <a class="menu-item" href="armor-calc.html">練磨(防具)自動選定ツール</a><br>
    </div>
    </br>
    <span class="toggle-button" data-target="linkList1">アイテム獲得チェッカー</span>
    <div id="linkList1">
      ├ <a class="menu-item" href="checker-4gen.html">四元像ピアスチェッカー</a></br>
      ├ <a class="menu-item" href="checker-stella.html">ステライヤリングチェッカー</a></br>
      └ <a class="menu-item" href="checker-niji.html">虹瑠璃の腕輪チェッカー</a></br>
    </div>
    <span class="toggle-button" data-target="linkList2">アイテム獲得報告用</span>
    <div id="linkList2">
      ├ <a class="menu-item" href="report-4gen.html">四元像ピアス報告用</a></br>
      ├ <a class="menu-item" href="report-stella.html">ステライヤリング報告用</a></br>
      └ <a class="menu-item" href="report-niji.html">虹瑠璃の腕輪報告用</a></br>
    </div>
    </br>
    <a class="menu-item" href="expcalc.html">EXPスタンプ必要数計算</a><br>
    <a class="menu-item" href="https://jessy-rs.github.io/Multi-Stage-Slash/">多段斬りアプリ</a><br>
    </br>
    <a class="menu-item"  href="armor.html">装備候補検索ツール</a><br>
    <a class="menu-item"  href="style-info.html">スタイル情報ビューア</a><br>
    <br>
    <a class="menu-item"  href="repeat.html">周回編成まとめ</a><br>
    <br>
    <a class="menu-item" href="index.html">インデックスページ</a><br>
    </br>
  </div>

    <div class="main-container">
        <header>
            <h1><span class="hamburger" onclick="toggleMenu()">☰</span>練磨(防具)自動選定ツール</h1>
        </header>

        <div class="zoom-buttons">
            <button onclick="changeZoom(0.1)">＋</button>
            <button onclick="changeZoom(-0.1)">－</button>
        </div>

        <div class="file-input-container">
            <input type="file" id="json-file-input" accept=".json">
            <p id="file-status">ファイルが選択されていません</p>
        </div>

        <div class="character-grid" id="character-grid">
        </div>

        <div class="global-controls">
            <button class="calculate-button" id="calculate-all-button" disabled>全キャラクターをまとめて計算</button>
        </div>
    </div>

    <footer>
        ※使用は自己責任にて。<br>
        ※最適な組み合わせが選定出来ない可能性もあります。あくまで参考としてお考えください。<br>
        ※名将の鎧の固有アビリティ考慮で威力＋選択のキャラにシリーズ指定した場合は、味方威力＋選択のキャラも威力＋選択のキャラとシリーズが同じであるなら必ず指定してください。<br>
        ※シリーズで「その他」を選択してもバトルヴァンブレイズに対応するものはありません。
    </footer>

    <div class="bottom">
        <a href="armor-renma.html">リストページへ</a>　<a href="armor-top5.html">TOP5ページへ</a>
        <br>
        <a href="index.html">INDEXへ戻る</a>
    </div>

    <script>

    // ハンバーガーメニューの関数
    function toggleMenu() {
        const sideMenu = document.getElementById('sideMenu');
        const menuOverlay = document.getElementById('menuOverlay');

        if (sideMenu.classList.contains('open')) {
            closeMenu();
        } else {
            sideMenu.classList.add('open');
            menuOverlay.classList.add('open');
        }
    }

    function closeMenu() {
        const sideMenu = document.getElementById('sideMenu');
        const menuOverlay = document.getElementById('menuOverlay');
        const menuClose = document.getElementById('menuClose');

        sideMenu.classList.remove('open');
        menuOverlay.classList.remove('open');
        menuClose.style.color = '#eee';
    }

    // フリックでメニュー開閉（スクロール誤作動対策版）
    let startX = 0, startY = 0;
    let endX = 0, endY = 0;

    document.addEventListener('touchstart', function (e) {
      // タッチ開始時のX座標とY座標を記録
      startX = e.changedTouches[0].screenX;
      startY = e.changedTouches[0].screenY;
    }, false);

    document.addEventListener('touchend', function (e) {
      // タッチ終了時のX座標とY座標を記録
      endX = e.changedTouches[0].screenX;
      endY = e.changedTouches[0].screenY;
      handleGesture(); // ジェスチャーを判定する関数を呼び出し
    }, false);

    function handleGesture() {
      const diffX = endX - startX; // 水平方向の移動量
      const diffY = endY - startY; // 垂直方向の移動量

      // 条件1: 水平方向の移動量が、垂直方向の移動量よりも大きい場合のみ処理（スワイプかスクロールかを判定）
      if (Math.abs(diffX) > Math.abs(diffY)) {

        // 条件2-1: 右へのスワイプ（50px以上移動し、かつ画面の左端30px以内から開始）
        if (diffX > 50 && startX < 30) {
          // 右にフリックしてメニューを開く
          toggleMenu();
        } 
        // 条件2-2: 左へのスワイプ（50px以上移動）
        else if (diffX < -50) {
          // 左にフリックしてメニューを閉じる
          closeMenu();
        }
      }
      // 垂直方向の移動量が大きい場合は、何もしない（ブラウザの標準スクロールに任せる）
    }

    // 拡大縮小の関数
    const PAGE_SETTING_KEY = 'PageSettings'; 
    
    let pageSettings = { 'armor-calc_zoom': 1.0 };
    
    function changeZoom(delta) {
        const zoomKey = 'armor-calc_zoom';
        let currentZoom = pageSettings[zoomKey];
    
        currentZoom += delta;

        currentZoom = Math.round(currentZoom * 10) / 10;

        if (currentZoom < 0.5) currentZoom = 0.5;
        if (currentZoom > 2.0) currentZoom = 2.0;
        
        // 画面の表示に反映
        document.body.style.zoom = currentZoom;
        
        // 設定オブジェクトの値を更新
        pageSettings[zoomKey] = currentZoom;
        
        // localStorageに保存
        savePageSettings();
    }
    
    function loadPageSettings() {
        try {
            const savedSettings = localStorage.getItem(PAGE_SETTING_KEY);
            if (savedSettings) {
                // 保存済みの設定があれば、デフォルト値と結合して上書きします。
                pageSettings = { ...pageSettings, ...JSON.parse(savedSettings) };
            }
        } catch (error) {
            console.error("ページ設定の読み込みに失敗しました:", error);
        }
    }
    
    function savePageSettings() {
        try {
            localStorage.setItem(PAGE_SETTING_KEY, JSON.stringify(pageSettings));
        } catch (error) {
            console.error("ページ設定の保存に失敗しました:", error);
        }
    }
        
        function scrollToCategory(categoryId) {
            const element = document.getElementById(categoryId);
            if (element) {
                element.scrollIntoView({ behavior: 'smooth', block: 'start' });
            }
        }

    document.addEventListener('DOMContentLoaded', () => {
        loadPageSettings();

        let armorData = [];
        // 装備固有アビリティ(CSV)を格納するMap
        let mainNativeAbilities = new Map();
        let subNativeAbilities = new Map();

        const fileInput = document.getElementById('json-file-input');
        const fileStatus = document.getElementById('file-status');
        const characterGrid = document.getElementById('character-grid');
        const calculateAllButton = document.getElementById('calculate-all-button');

        const abilityConditions = [
            { name: "HP満タン時", value: "HP満タン時" }, { name: "瀕死時", value: "瀕死時" },
            { name: "カウンター", value: "カウンター" }, { name: "斬", value: "斬" },
            { name: "打", value: "打" }, { name: "突", value: "突" },
            { name: "熱", value: "熱" }, { name: "冷", value: "冷" },
            { name: "雷", value: "雷" }, { name: "陽", value: "陽" },
            { name: "陰", value: "陰" }
        ];
        
        const seriesNames = ["未選択", "GBSaGa", "RS1", "RS2", "RS3", "SF1", "SF2", "US", "ES", "IS", "SSG", "SaGaRS", "SaGaEB", "その他"];

        /**
         * CSVファイルを読み込み、指定されたMapオブジェクトにデータを格納する関数
         * @param {string} url - CSVファイルのパス
         * @param {Map} targetMap - 格納先のMapオブジェクト
         */
        async function loadCsvData(url, targetMap) {
            try {
                const response = await fetch(url);
                if (!response.ok) {
                    throw new Error(`Network response was not ok for ${url}`);
                }
                const csvText = await response.text();
                const lines = csvText.trim().split('\n');
                lines.shift(); // ヘッダー行をスキップ

                lines.forEach(line => {
                    const [name, target, valueStr] = line.split(',');
                    if (name && target && valueStr) {
                        const value = parseInt(valueStr.trim(), 10);
                        if (!isNaN(value)) {
                            if (!targetMap.has(name.trim())) {
                                targetMap.set(name.trim(), []);
                            }
                            targetMap.get(name.trim()).push({ target: target.trim(), value });
                        }
                    }
                });
                console.log(`Successfully loaded and parsed: ${url}`);
            } catch (error) {
                console.error(`Error loading or parsing CSV from ${url}:`, error);
                fileStatus.innerHTML += `<br><span style="color: red;">${url} の読み込みに失敗しました。</span>`;
            }
        }
        
        /**
         * 「味方威力＋」選択時の条件を同期する関数
         * @param {number} charId - 変更が発生したキャラクターのID (1-5)
         * @param {string} eventType - 'radio-change' または 'checkbox-change'
         */
        function handleConditionSync(charId, eventType) {

            // 特別要件: キャラクター2のラジオボタンが「味方威力＋」に変更された場合
            if (charId === 2 && eventType === 'radio-change' && document.querySelector('input[name="ability-type-2"]:checked').value === '味方威力＋') {
                
                // 1. キャラクター1の条件を取得 (アビリティタイプは問わない)
                const sourceConditions = Array.from(document.querySelectorAll('input[name="condition-1"]:checked')).map(cb => cb.value);

                // 2. キャラクター2から5まで、アビリティタイプと条件を同期
                for (let i = 2; i <= 5; i++) {
                    // アビリティタイプを「味方威力＋」に設定
                    document.querySelector(`input[name="ability-type-${i}"][value="味方威力＋"]`).checked = true;
                    
                    // 条件をキャラクター1の状態に同期
                    const targetCheckboxes = document.querySelectorAll(`input[name="condition-${i}"]`);
                    targetCheckboxes.forEach(cb => {
                        cb.checked = sourceConditions.includes(cb.value);
                    });
                }
                
                // 3. 計算ボタンまでスクロール
                const calculateButton = document.getElementById('calculate-all-button');
                if (calculateButton) {
                    // ボタンが画面の中央に来るようにスクロール
                    calculateButton.scrollIntoView({ behavior: 'smooth', block: 'center' });
                }

                // この特別な処理が完了したら、以降の通常処理は行わない
                return; 
            }

            const currentAbilityType = document.querySelector(`input[name="ability-type-${charId}"]:checked`).value;

            // --- Logic for BECOMING a party buffer ---
            // If the event was a radio button change and the new type is "味方威力＋"
            if (eventType === 'radio-change' && currentAbilityType === '味方威力＋') {
                let conditionsToCopy = null;
                // Find the first previous character who is also a party buffer
                for (let i = charId - 1; i >= 1; i--) {
                    const prevAbilityType = document.querySelector(`input[name="ability-type-${i}"]:checked`).value;
                    if (prevAbilityType === '味方威力＋') {
                        // Get their conditions
                        conditionsToCopy = Array.from(document.querySelectorAll(`input[name="condition-${i}"]:checked`)).map(cb => cb.value);
                        break; // Stop at the first one
                    }
                }
                
                // If we found a previous buffer, apply their conditions to the current character
                if (conditionsToCopy !== null) {
                    const currentCheckboxes = document.querySelectorAll(`input[name="condition-${charId}"]`);
                    currentCheckboxes.forEach(cb => {
                        cb.checked = conditionsToCopy.includes(cb.value);
                    });
                }
            }

            // --- Logic for UPDATING subsequent party buffers ---
            // If the current character is a party buffer (regardless of what event happened)
            if (currentAbilityType === '味方威力＋') {
                const sourceConditions = Array.from(document.querySelectorAll(`input[name="condition-${charId}"]:checked`)).map(cb => cb.value);
                
                // Update all subsequent characters who are also party buffers
                for (let i = charId + 1; i <= 5; i++) {
                    const nextAbilityType = document.querySelector(`input[name="ability-type-${i}"]:checked`).value;
                    if (nextAbilityType === '味方威力＋') {
                        const nextCheckboxes = document.querySelectorAll(`input[name="condition-${i}"]`);
                        nextCheckboxes.forEach(cb => {
                            cb.checked = sourceConditions.includes(cb.value);
                        });
                    }
                }
            }
        }

        // ページの初期化処理
        async function initialize() {
            // キャラクターUIを生成
            for (let i = 1; i <= 5; i++) {
                const charContainer = document.createElement('div');
                charContainer.className = 'character-container';
                charContainer.id = `char-${i}`;
                
                let checkboxesHTML = '';
                abilityConditions.forEach(cond => {
                    const uniqueId = `condition-${i}-${cond.value.replace(/\s/g, '-')}`;
                    checkboxesHTML += `<input type="checkbox" name="condition-${i}" value="${cond.value}" id="${uniqueId}"><label for="${uniqueId}">${cond.name}</label>`;
                });
                
                let seriesOptionsHTML = '';
                seriesNames.forEach(name => {
                    seriesOptionsHTML += `<option value="${name}">${name}</option>`;
                });

                charContainer.innerHTML = `
                    <h2>
                        <span>キャラ ${i}</span>
                        <select class="series-select" id="series-select-${i}">${seriesOptionsHTML}</select>
                        <div class="nav-buttons">
                            <button class="nav-button" id="nav-up-${i}">▲</button>
                            <button class="nav-button" id="nav-down-${i}">▼</button>
                        </div>
                    </h2>
                    <div class="form-horizontal-row">
                        <div class="form-type">
                            <fieldset class="form-section">
                                <legend>アビリティ</legend>
                                <div class="styled-form-group">
                                    <input type="radio" name="ability-type-${i}" value="威力＋" id="ability-type-${i}-power" checked><label for="ability-type-${i}-power">威力＋</label>
                                    <input type="radio" name="ability-type-${i}" value="味方威力＋" id="ability-type-${i}-party"><label for="ability-type-${i}-party">味方威力＋</label>
                                </div>
                            </fieldset>
                        </div>
                        <div class="form-conditions">
                            <fieldset class="form-section">
                                <legend>条件 (複数可)</legend>
                                <div class="styled-form-group conditions-wrapper">${checkboxesHTML}</div>
                            </fieldset>
                        </div>
                    </div>
                    <div class="result-area" id="result-area-${i}"><p>計算結果がここに表示されます。</p></div>
                `;

                characterGrid.appendChild(charContainer);
                
                const navUpButton = charContainer.querySelector(`#nav-up-${i}`);
                const navDownButton = charContainer.querySelector(`#nav-down-${i}`);

                if (i === 1) {
                    navUpButton.disabled = true;
                } else {
                    navUpButton.addEventListener('click', () => scrollToCategory(`char-${i - 1}`));
                }

                if (i === 5) {
                    navDownButton.disabled = true;
                } else {
                    navDownButton.addEventListener('click', () => scrollToCategory(`char-${i + 1}`));
                }

                const newRadios = charContainer.querySelectorAll(`input[name="ability-type-${i}"]`);
                newRadios.forEach(radio => radio.addEventListener('change', () => handleConditionSync(i, 'radio-change')));

                const newCheckboxes = charContainer.querySelectorAll(`input[name="condition-${i}"]`);
                newCheckboxes.forEach(checkbox => checkbox.addEventListener('change', () => handleConditionSync(i, 'checkbox-change')));
            }

            // CSVデータを非同期で読み込む
            await Promise.all([
                loadCsvData('data/armor-main-ability.csv', mainNativeAbilities),
                loadCsvData('data/armor-sub-ability.csv', subNativeAbilities)
            ]);
        }
        
        // 初期化実行
        initialize();

        fileInput.addEventListener('change', (event) => {
            const file = event.target.files[0];
            if (!file) return;
            const reader = new FileReader();
            reader.onload = (e) => {
                try {
                    const rawData = JSON.parse(e.target.result);
                    armorData = rawData.map(item => ({...item, value: parseInt(item.value, 10)})).filter(item => !isNaN(item.value));
                    fileStatus.textContent = `読み込み完了: ${file.name}`;
                    fileStatus.style.color = '#98fb98';
                    calculateAllButton.disabled = false;
                } catch (error) {
                    alert('JSONファイルの読み込みまたは解析に失敗しました。\n' + error);
                    fileStatus.textContent = 'エラー: ファイルを読み込めません';
                    fileStatus.style.color = 'red';
                    armorData = [];
                    calculateAllButton.disabled = true;
                }
            };
            reader.readAsText(file);
        });
        
        function getConditionFromAbilityName(abilityName) {
            if (!abilityName) return null;
            const match = abilityName.match(/\((.*)\)/);
            return match ? match[1] : null;
        }

        /**
         * [修正済み] 装備の固有アビリティ(CSV)の効果値を取得する関数
         * @param {string} armorName - 防具名
         * @param {string} armorType - 'main' または 'sub'
         * @param {string[]} selectedConditions - キャラクターが選択した全ての条件の配列
         * @param {string} abilityType - '威力＋' または '味方威力＋'
         * @param {number} charId - 現在のキャラクターID
         * @returns {number} - 固有アビリティの効果値の合計
         */
        function getNativeAbilityValue(armorName, armorType, selectedConditions, abilityType, charId) {
            const nativeAbilityMap = armorType === 'main' ? mainNativeAbilities : subNativeAbilities;
            if (!nativeAbilityMap.has(armorName)) return 0;
            
            const selectedSeries = document.getElementById(`series-select-${charId}`).value;
            let totalValue = 0;
            const abilities = nativeAbilityMap.get(armorName);

            for (const ability of abilities) {
                let shouldAddValue = true;

                // シリーズ装備のシリーズ一致判定
                if (armorName.includes('名将の鎧') || armorName.includes('☆ﾊﾞﾄﾙｳﾞｧﾝﾌﾞﾚｲｽ')) {
                    if (selectedSeries === '未選択') {
                        shouldAddValue = false;
                    } else {
                        const armorSeriesMatch = armorName.match(/\(([^)]+)\)/);
                        if (armorSeriesMatch) {
                            const armorSeriesStr = armorSeriesMatch[1];
                            if (armorName.includes('☆ﾊﾞﾄﾙｳﾞｧﾝﾌﾞﾚｲｽ') && armorSeriesStr === 'US・ES・IS') {
                                if (!['US', 'ES', 'IS'].includes(selectedSeries)) {
                                    shouldAddValue = false;
                                }
                            } else {
                                const armorSeriesList = armorSeriesStr.split(/[&＆]/).map(s => s.trim());
                                if (!armorSeriesList.includes(selectedSeries)) {
                                    shouldAddValue = false;
                                }
                            }
                        }
                    }
                }

                if (shouldAddValue) {
                    const nativeAbilityTarget = ability.target;
                    
                    // キャラクターの選択アビリティに応じて加算するCSV値を切り替える
                    if (abilityType === '味方威力＋') {
                        // 「味方威力＋」選択時は、対象が「味方威力」のCSV値のみ加算
                        if (nativeAbilityTarget === '味方威力') {
                            totalValue += ability.value;
                        }
                    } else { // '威力＋' の場合
                        // 「威力＋」選択時は、対象が「威力」「味方威力」または選択条件に合致するものを加算
                        const isUnconditional = nativeAbilityTarget === '威力' || nativeAbilityTarget === '味方威力';
                        const isConditionMet = selectedConditions.includes(nativeAbilityTarget);
                        if (isUnconditional || isConditionMet) {
                            totalValue += ability.value;
                        }
                    }
                }
            }
            return totalValue;
        }

        /**
         * JSON値とCSV値を合算した総合値で最適な防具を見つける関数
         * @param {string} armorType - 'main' or 'sub'
         * @param {object} character - The character config object
         * @param {Set<string>} excludedItems - 既に装備済みの防具名のSet
         * @param {object[]} partyConfig - パーティ全体の設定配列
         * @returns {object} - 最適な防具の情報 (nativeValue含む)
         */
        function findBestArmorWithNativeAbilities(armorType, character, excludedItems, partyConfig) {
            const { abilityType, selectedConditions, charId, series } = character;
            const candidates = [];

            const availableArmor = armorData.filter(item =>
                item.armorType === armorType &&
                !excludedItems.has(item.armorName)
            );

            for (const armor of availableArmor) {
                const jsonAbilityCondition = getConditionFromAbilityName(armor.abilityName);
                const jsonAbilityType = armor.abilityName.includes('味方威力＋') ? '味方威力＋' : '威力＋';
                
                let typeMatch = (abilityType === jsonAbilityType);
                if (abilityType === '威力＋' && jsonAbilityType === '味方威力＋') {
                    typeMatch = true;
                }

                if (typeMatch && selectedConditions.includes(jsonAbilityCondition)) {
                    const jsonValue = armor.value;
                    const nativeValue = getNativeAbilityValue(armor.armorName, armorType, selectedConditions, abilityType, charId);
                    
                    let combinedValue;
                    if (abilityType === '味方威力＋' && armor.armorName.includes('名将の鎧') && armor.armorType === 'main') {
                        let isBeneficialToParty = false;
                        if (series !== '未選択') {
                            const armorSeriesMatch = armor.armorName.match(/\(([^)]+)\)/);
                            if (armorSeriesMatch) {
                                const armorSeries = armorSeriesMatch[1].split(/[&＆]/).map(s => s.trim());
                                if (armorSeries.includes(series)) {
                                    for (const member of partyConfig) {
                                        if (member.charId === charId) continue;
                                        if (member.abilityType === '威力＋' && member.series === series) {
                                            isBeneficialToParty = true;
                                            break;
                                        }
                                    }
                                }
                            }
                        }
                        combinedValue = isBeneficialToParty ? (jsonValue + nativeValue) : jsonValue;
                    } else {
                        combinedValue = jsonValue + nativeValue;
                    }

                    candidates.push({ ...armor, combinedValue });
                }
            }

            if (candidates.length === 0) {
                return { armorName: '該当なし', value: 0, abilityName: '-' };
            }

            candidates.sort((a, b) => b.combinedValue - a.combinedValue);
            return candidates[0];
        }
        
        function runIterativeSolver(partyConfig, lockedEquipment = new Map()) {
            let partyLoadout = Array(5).fill(null);
            let lastLoadoutStr = "";
            let iterations = 0;

            while (JSON.stringify(partyLoadout) !== lastLoadoutStr && iterations < 5) {
                lastLoadoutStr = JSON.stringify(partyLoadout);
                iterations++;

                const equippedThisPass = new Set();
                lockedEquipment.forEach(loadout => {
                    if (loadout.mainArmor) equippedThisPass.add(loadout.mainArmor.armorName);
                    if (loadout.subArmor) equippedThisPass.add(loadout.subArmor.armorName);
                });

                const nextLoadout = [];

                for (const character of partyConfig) {
                    const { charId } = character;
                    let mainArmor, subArmor;

                    if (lockedEquipment.has(charId) && lockedEquipment.get(charId).mainArmor) {
                        mainArmor = lockedEquipment.get(charId).mainArmor;
                    } else {
                         mainArmor = findBestArmorWithNativeAbilities('main', character, equippedThisPass, partyConfig);
                    }
                    if (mainArmor.armorName !== '該当なし') equippedThisPass.add(mainArmor.armorName);
                    
                    if (lockedEquipment.has(charId) && lockedEquipment.get(charId).subArmor) {
                        subArmor = lockedEquipment.get(charId).subArmor;
                    } else {
                        subArmor = findBestArmorWithNativeAbilities('sub', character, equippedThisPass, partyConfig);
                    }
                    if (subArmor.armorName !== '該当なし') equippedThisPass.add(subArmor.armorName);
                    
                    nextLoadout[charId - 1] = { mainArmor, subArmor };
                }
                partyLoadout = nextLoadout;
            }
            return partyLoadout;
        }

        function calculateFinalResults(partyLoadout, partyConfig) {
            const characterResults = [];
            // Step 1: 装備構成に基づいて、各装備の正確な固有アビリティ効果値（nativeValue）を計算し、結果を補強する
            for (const character of partyConfig) {
                const { charId, abilityType, selectedConditions } = character;
                const equipment = partyLoadout[charId - 1];
                if (!equipment) { 
                    characterResults.push({ charId, abilityType, selectedConditions, mainArmor: {armorName: 'エラー'}, subArmor: {armorName: 'エラー'}, totals: {grand: -1}});
                    continue;
                }
                const { mainArmor, subArmor } = equipment;

                // 各装備が持つポテンシャルとしての固有アビリティ値を計算
                mainArmor.nativeValue = getNativeAbilityValue(mainArmor.armorName, 'main', selectedConditions, abilityType, charId);
                subArmor.nativeValue = getNativeAbilityValue(subArmor.armorName, 'sub', selectedConditions, abilityType, charId);

                characterResults.push({ ...character, mainArmor, subArmor });
            }

            // Step 2: 全員の装備と効果値が確定した状態で、各キャラクターの最終的な合計値を計算する
            for (const receiver of characterResults) {
                // 自身の装備による効果を計算
                const selfValue = (receiver.mainArmor.value || 0) + (receiver.subArmor.value || 0) + (receiver.mainArmor.nativeValue || 0) + (receiver.subArmor.nativeValue || 0);

                // 他のキャラクターからの「味方威力＋」による効果を計算
                let partyValue = 0;
                for (const provider of characterResults) {
                    if (receiver.charId === provider.charId) continue; // 自分自身からのバフは含めない

                    // receiverとproviderで共通の条件がなければ、バフは発生しない
                    const commonConditions = receiver.selectedConditions.filter(c => provider.selectedConditions.includes(c));
                    if (commonConditions.length === 0) continue;

                    let contribution = 0;
                    // --- 主防具からの貢献 ---
                    const mainCond = getConditionFromAbilityName(provider.mainArmor.abilityName);
                    if (provider.mainArmor.abilityName.includes("味方威力＋") && provider.selectedConditions.includes(mainCond)) {
                        contribution += provider.mainArmor.value;
                    }
                    // 固有アビリティ(CSV)に「味方威力」がある場合の貢献
                    if (mainNativeAbilities.has(provider.mainArmor.armorName) && mainNativeAbilities.get(provider.mainArmor.armorName).some(a => a.target === '味方威力')) {
                        const hasMeisho = provider.mainArmor.armorName.includes('名将の鎧');
                        if (hasMeisho) {
                            let isMatch = false;
                            // 名将の鎧の場合、providerとreceiverのシリーズが一致し、かつ装備のシリーズ指定とも一致する必要がある
                            if (receiver.series !== '未選択' && receiver.series === provider.series) {
                                const armorSeriesMatch = provider.mainArmor.armorName.match(/\(([^)]+)\)/);
                                if (armorSeriesMatch) {
                                    const armorSeriesList = armorSeriesMatch[1].split(/[&＆]/).map(s => s.trim());
                                    if (armorSeriesList.includes(receiver.series)) {
                                        isMatch = true;
                                    }
                                }
                            }
                            if (isMatch) {
                                contribution += provider.mainArmor.nativeValue;
                            }
                        } else {
                            // 名将の鎧以外で「味方威力」を持つ装備の場合
                            contribution += provider.mainArmor.nativeValue;
                        }
                    }

                    // --- 副防具からの貢献 ---
                    const subCond = getConditionFromAbilityName(provider.subArmor.abilityName);
                    if (provider.subArmor.abilityName.includes("味方威力＋") && provider.selectedConditions.includes(subCond)) {
                        contribution += provider.subArmor.value;
                    }
                    if (subNativeAbilities.has(provider.subArmor.armorName) && subNativeAbilities.get(provider.subArmor.armorName).some(a => a.target === '味方威力')) {
                        contribution += provider.subArmor.nativeValue;
                    }
                    
                    partyValue += contribution;
                }
                
                // 最終的な合計値を格納
                if (receiver.abilityType === '威力＋') {
                    receiver.totals = { self: selfValue, party: partyValue, grand: selfValue + partyValue };
                } else { // '味方威力＋'
                    const hasMeisho = receiver.mainArmor.armorName.includes('名将の鎧');
                    if (hasMeisho) {
                        const normalValue = (receiver.mainArmor.value || 0) + (receiver.subArmor.value || 0) + (receiver.subArmor.nativeValue || 0);
                        receiver.totals = { isMeisho: true, meishoTotal: selfValue, normalTotal: normalValue };
                    } else {
                        receiver.totals = { self: selfValue };
                    }
                }
            }
            return characterResults;
        }

        function calculateAllCharacters() {
            window.scrollTo({ top: 0, behavior: 'smooth' });
            
            // Step 1: UIから現在のパーティ設定を読み込む
            const partyConfig = [];
            let primaryAttacker = null;
            for (let i = 1; i <= 5; i++) {
                const charConfig = {
                    charId: i,
                    abilityType: document.querySelector(`input[name="ability-type-${i}"]:checked`).value,
                    selectedConditions: Array.from(document.querySelectorAll(`input[name="condition-${i}"]:checked`)).map(cb => cb.value),
                    series: document.getElementById(`series-select-${i}`).value
                };
                partyConfig.push(charConfig);
                // 最初の「威力＋」キャラをプライマリアタッカーとして設定
                if (charConfig.abilityType === '威力＋' && !primaryAttacker) {
                    primaryAttacker = charConfig;
                }
            }

            // アタッカーがいない場合は、単純な最適化のみ実行して終了
            if (!primaryAttacker) {
                const loadout = runIterativeSolver(partyConfig);
                const results = calculateFinalResults(loadout, partyConfig);
                results.forEach(r => displayResult(r));
                return;
            }

            let bestLoadout = null;
            let bestTotal = -1;

            // Step 2: アタッカーが装備しうる主防具の候補をリストアップ
            const attackerCandidates = [];
            const availableMainArmor = armorData.filter(item => item.armorType === 'main');

            for (const armor of availableMainArmor) {
                const jsonAbilityCondition = getConditionFromAbilityName(armor.abilityName);
                if (primaryAttacker.selectedConditions.includes(jsonAbilityCondition)) {
                    const jsonAbilityType = armor.abilityName.includes('味方威力＋') ? '味方威力＋' : '威力＋';
                    // アタッカーは「威力＋」と「味方威力＋」の両方を装備候補にできる
                    if (jsonAbilityType === '威力＋' || jsonAbilityType === '味方威力＋') {
                         attackerCandidates.push(armor);
                    }
                }
            }

            // Step 3: 試すべきシナリオを生成する
            // 候補を「威力+」「味方威力+」に分類し、それぞれの効果値（JSON値+CSV値）でソート
            const powerPlusCandidates = attackerCandidates
                .filter(a => !a.abilityName.includes('味方威力＋'))
                .map(a => ({ ...a, totalValue: a.value + getNativeAbilityValue(a.armorName, 'main', primaryAttacker.selectedConditions, primaryAttacker.abilityType, primaryAttacker.charId) }))
                .sort((a, b) => b.totalValue - a.totalValue);

            const partyBuffCandidates = attackerCandidates
                .filter(a => a.abilityName.includes('味方威力＋'))
                .map(a => ({ ...a, totalValue: a.value + getNativeAbilityValue(a.armorName, 'main', primaryAttacker.selectedConditions, primaryAttacker.abilityType, primaryAttacker.charId) }))
                .sort((a, b) => b.totalValue - a.totalValue);

            // テストするシナリオ: 「威力+」上位2つ、「味方威力+」上位3つ
            const scenariosToTest = [
                ...powerPlusCandidates.slice(0, 2),
                ...partyBuffCandidates.slice(0, 3)
            ];
            
            const uniqueScenarios = [...new Map(scenariosToTest.map(item => [item.armorName, item])).values()];
            // 「ロックなし」のケースを追加。これにより、ソルバーが自由に選択するベースラインも評価される
            uniqueScenarios.push(null); 

            // Step 4: 各シナリオをテスト実行
            for (const attackerMainArmor of uniqueScenarios) {
                const lockedEquipment = new Map();
                // アタッカーの主防具をシナリオ通りに固定（nullの場合は固定しない）
                if (attackerMainArmor) {
                    lockedEquipment.set(primaryAttacker.charId, { mainArmor: attackerMainArmor, subArmor: null });
                }
                
                // このロック状態で、パーティ全体の最適な装備構成を計算
                const scenarioLoadout = runIterativeSolver(partyConfig, lockedEquipment);
                const scenarioResults = calculateFinalResults(scenarioLoadout, partyConfig);
                const scenarioAttackerResult = scenarioResults.find(r => r.charId === primaryAttacker.charId);
                
                // アタッカーの最終合計値（grand total）を比較し、最良の結果を更新
                if (scenarioAttackerResult && scenarioAttackerResult.totals && scenarioAttackerResult.totals.grand > bestTotal) {
                    bestTotal = scenarioAttackerResult.totals.grand;
                    bestLoadout = scenarioLoadout;
                }
            }

            // Step 5: 全シナリオの中で最も良かった結果を表示
            if (bestLoadout) {
                const finalResults = calculateFinalResults(bestLoadout, partyConfig);
                finalResults.forEach(r => displayResult(r));
            } else {
                // 万が一、適切な装備が一つも見つからなかった場合
                partyConfig.forEach(c => displayEmptyResult(c.charId));
            }
        }
        
        function displayResult(result) {
            const { charId, mainArmor, subArmor, totals } = result;
            const resultArea = document.getElementById(`result-area-${charId}`);
            
            let mainArmorNameStyle = '';
            if (!mainArmor || mainArmor.armorName === '該当なし') {
                mainArmorNameStyle = 'style="color: red;"';
            } else if (mainArmor.armorName.includes('名将の鎧') || mainArmor.armorName.includes('ﾊﾞﾄﾙｳﾞｧﾝﾌﾞﾚｲｽ')) {
                mainArmorNameStyle = 'style="color: magenta;"';
            } else if (mainArmor.nativeValue > 0) {
                mainArmorNameStyle = 'style="color: orange;"';
            }
            const mainArmorNameText = mainArmor.nativeValue > 0 && mainArmor.armorName !== '該当なし' ? `${mainArmor.armorName}(+${mainArmor.nativeValue})` : mainArmor.armorName;
            
            let subArmorNameStyle = '';
             if (!subArmor || subArmor.armorName === '該当なし') {
                subArmorNameStyle = 'style="color: red;"';
            } else if (subArmor.armorName.includes('名将の鎧') || subArmor.armorName.includes('ﾊﾞﾄﾙｳﾞｧﾝﾌﾞﾚｲｽ')) {
                subArmorNameStyle = 'style="color: magenta;"';
            } else if (subArmor.nativeValue > 0) {
                subArmorNameStyle = 'style="color: orange;"';
            }
            const subArmorNameText = subArmor.nativeValue > 0 && subArmor.armorName !== '該当なし' ? `${subArmor.armorName}(+${subArmor.nativeValue})` : subArmor.armorName;

            let totalHTML = '';

            if (totals.isMeisho) {
                totalHTML = `
                    <div class="total-container">
                        <div class="total-row"><span class="label">名将:</span><span class="value">${totals.meishoTotal}%</span></div>
                        <div class="total-row final-total"><span class="label">通常:</span><span class="value">${totals.normalTotal}%</span></div>
                    </div>
                `;
            } else if (totals.grand !== undefined) { 
                totalHTML = `
                    <div class="total-container">
                        <div class="total-row"><span class="label">自身:</span><span class="value">${totals.self}%</span></div>
                        <div class="total-row"><span class="label">味方:</span><span class="value">${totals.party}%</span></div>
                        <div class="total-row final-total"><span class="label">合計:</span><span class="value">${totals.grand}%</span></div>
                    </div>
                `;
            } else { 
                totalHTML = `
                    <div class="total-container">
                        <div class="total-row final-total"><span class="label">合計:</span><span class="value">${totals.self}%</span></div>
                    </div>
                `;
            }

            resultArea.innerHTML = `
                <div class="result-details">
                    <table class="result-table">
                        <tbody>
                            <tr>
                                <td class="col-heading"><span class="heading-text">主防具</span></td>
                                <td class="col-armor">
                                    <span class="data-label">装備:</span><span class="armor-text" ${mainArmorNameStyle}>${mainArmorNameText || ''}</span>
                                </td>
                                <td class="col-ability">
                                    <span class="data-label">アビリティ:</span><span class="ability-text">${mainArmor.abilityName || '-'}</span>
                                </td>
                                <td class="col-value">
                                    <span class="data-label">効果値:</span><span class="value-text">${mainArmor.value || 0}%</span>
                                </td>
                            </tr>
                            <tr>
                                <td class="col-heading"><span class="heading-text">副防具</span></td>
                                <td class="col-armor">
                                    <span class="data-label">装備:</span><span class="armor-text" ${subArmorNameStyle}>${subArmorNameText || ''}</span>
                                </td>
                                <td class="col-ability">
                                    <span class="data-label">アビリティ:</span><span class="ability-text">${subArmor.abilityName || '-'}</span>
                                </td>
                                <td class="col-value">
                                    <span class="data-label">効果値:</span><span class="value-text">${subArmor.value || 0}%</span>
                                </td>
                            </tr>
                        </tbody>
                    </table>
                </div>
                ${totalHTML}
            `;
        }

        function displayEmptyResult(charId) {
            const resultArea = document.getElementById(`result-area-${charId}`);
            resultArea.innerHTML = `<p>条件を選択して計算を実行してください。</p>`;
        }

        calculateAllButton.addEventListener('click', calculateAllCharacters);

        document.body.style.zoom = pageSettings['armor-calc_zoom'];
    });

    document.addEventListener("DOMContentLoaded", function(){
      var toggleButtons = document.querySelectorAll(".toggle-button");
    
      toggleButtons.forEach(function(button) {
        var targetId = button.getAttribute("data-target");
        var list = document.getElementById(targetId);
        list.style.display = "none";
    
        button.addEventListener("click", function(){
          if (list.style.display === "block") {
            list.style.display = "none";
          } else {
            list.style.display = "block";
          }
        });
      });
    });

  </script>

</body>
</html>