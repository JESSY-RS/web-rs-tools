<!DOCTYPE html>
<html lang="ja">
<head>

    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="shortcut icon" href="favicon-renma.ico">
    <link rel="apple-touch-icon" href="apple-touch-icon-renma.png">
    <link rel="icon" type="image/png" href="web-app-manifest-192x192-renma.png">
    <title>練磨(防具)自動選定ツール</title> <style>
        /* --- 全体 --- */
        body {
            background-color: #2A2A2A;
            color: #eee;
            font-family: 'Meiryo', sans-serif;
            padding: 20px;
            margin: 0;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        /* --- ヘッダー --- */
        header { text-align: center; margin-bottom: 20px; }
        h1 { 
            color: #50b4f0; 
            margin: 0;
        }

        /* --- グローバルコンテナ --- */
        .main-container {
            width: 100%;
            max-width: 1600px;
        }
        
        /* --- ファイル入力 --- */
        .file-input-container {
            border-radius: 8px;
            margin-bottom: 20px;
            box-sizing: border-box;
            text-align: center;
        }
        #file-status { margin-top: 10px; color: #ffd700; }

        /* --- キャラクターグリッド (1列・5行レイアウト) --- */
        .character-grid {
            display: flex;
            flex-direction: column;
            gap: 20px;
            width: 100%;
        }

        /* --- キャラクターコンテナ --- */
        .character-container {
            background-color: #383838;
            border: 1px solid #555;
            border-radius: 8px;
            padding: 20px 20px;
        }
        
        h2 {
            color: #c0c0ff;
            margin: 0 0 15px 0;
            border-bottom: 2px solid #555;
            padding-bottom: 8px;
            margin-bottom: 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .nav-buttons {
            display: flex;
            gap: 6px;
        }

        .nav-button {
            background-color: #555;
            color: #eee;
            border: 1px solid #777;
            padding: 4px 8px;
            cursor: pointer;
            font-size: 12px;
            border-radius: 3px;
            transition: background-color 0.2s;
        }

        .nav-button:hover {
            background-color: #666;
        }

        .nav-button:active {
            background-color: #444;
        }

        .nav-button:disabled {
            background-color: #333;
            color: #666;
            cursor: default;
            opacity: 0.5;
        }

        /* --- フォームの横並びコンテナ --- */
        .form-horizontal-row {
            display: flex;
            align-items: flex-start;
            gap: 20px;
            margin-bottom: 20px;
        }

        /* --- フォームスタイル --- */
        .form-section {
            padding: 15px;
            border: 1px solid #444;
            border-radius: 5px;
        }
        .form-section legend {
            font-weight: bold;
            color: #98fb98;
            padding: 0 5px;
        }
        
        .form-type .form-group {
            display: flex;
            gap: 25px;
        }

        .form-conditions {
            flex-grow: 1;
        }
        .conditions-wrapper {
            display: flex;
            flex-wrap: wrap;
            gap: 10px 20px;
        }
        
        .form-group label {
            display: inline-flex;
            align-items: center;
            gap: 5px;
            cursor: pointer;
        }

        /* --- 結果表示 --- */
        .result-area {
            background-color: #2a2a2a;
            padding: 15px;
            border-radius: 5px;
            border: 1px dashed #777;
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: 20px;
        }
        
        .result-details {
            flex-grow: 1;
        }
        
        .result-table {
            width: 100%;
            border-collapse: collapse;
            table-layout: fixed;
        }
        .result-table td {
            padding: 8px;
            text-align: left;
            vertical-align: middle;
            border-bottom: 1px solid #3a3a3a;
        }
        .result-table tr:last-child td {
            border-bottom: none;
        }
        
        .col-heading { width: 7%; }
        .col-armor   { width: 33%; }
        .col-ability { width: 37%; }
        .col-value   { width: 23%; }
        
        .data-label {
            display: inline-block;
            text-align: right;
            margin-right: 8px;
            color: #a0a0a0;
        }

        .heading-text { color: #c0c0ff; font-weight: bold; }
        .armor-text   { color: #98fb98; }
        .ability-text { color: #ccc; }
        .value-text   { color: #ffd700; font-weight: bold; }
        
        .total-container {
            padding-left: 20px;
            border-left: 1px solid #555;
            white-space: nowrap;
            text-align: right;
        }
        .total-container .total-row {
            display: flex;
            justify-content: space-between;
            align-items: baseline;
            gap: 15px;
        }
        .total-container .label {
            font-size: 16px;
            color: #a0a0a0;
        }
        .total-container .value {
             font-weight: bold;
             font-size: 24px;
             color: #ffd700;
        }
        .total-container .final-total .label,
        .total-container .final-total .value {
            color: red; /* 合計の色 */
        }
        
        .global-controls {
            text-align: center;
            margin-top: 20px;
        }
        .calculate-button {
            background-color: #f0506e;
            color: #fff;
            border: none;
            padding: 15px 30px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 20px;
            font-weight: bold;
            transition: background-color 0.2s, transform 0.2s, box-shadow 0.2s;
        }
        .calculate-button:hover:not(:disabled) {
            background-color: #c8405a;
        }
        .calculate-button:active:not(:disabled) {
            transform: translateY(0);
        }
        .calculate-button:disabled {
            background-color: #555;
            color: #888;
            cursor: not-allowed;
        }

        /* 拡大縮小ボタンのスタイル - absolute positioned to not scroll */
        .zoom-buttons {
            position: absolute;
            top: 15px;
            right: 15px;
            display: flex;
            flex-direction: column;
            gap: 5px;
            z-index: 1000;
        }

        .zoom-buttons button {
            padding: 5px 10px;
            font-size: 14px;
            cursor: pointer;
        }

        a:link { color: #1D9BF0; text-decoration: underline; }
        a:visited { color: #7755FF; text-decoration: underline; }
        a:hover { color: #0CFF57; }
        a:active { color: #FF0000; text-decoration: underline; }

        footer {
            width: 100%;
            border-top: 1px solid #eee;
            padding-top: 10px;
            font-size: 12pt;
            margin-top: 40px;
        }

        .bottom {
            margin-top: 20px;
            font-size: 16pt;
            line-height: 2;
            text-align: center;
        }

        /* --- レスポンシブデザイン --- */

        /* 中サイズ画面 (幅992px以下) */
        @media (max-width: 992px) {
            /* 結果テーブルのセルを縦に並べる */
            .result-table tr {
                display: block;
                padding: 10px 0;
                border-bottom: 1px solid #3a3a3a;
            }
            .result-table tr:last-child {
                border-bottom: none;
                padding-bottom: 0;
            }
            .result-table td {
                display: block;
                width: 100%;
                border-bottom: none;
                padding: 5px 0;
            }

            /* 固定幅を解除 */
            .col-heading, .col-armor, .col-ability, .col-value {
                width: auto;
            }
            .data-label {
                width: 90px;
            }
        }

        /* 小サイズ画面 (幅768px以下) */
        @media (max-width: 768px) {
            /* 結果表示エリア全体を縦並びにする */
            .result-area {
                flex-direction: column;
                align-items: stretch;
            }
            
            /* 合計値コンテナを下に移動させるための調整 */
            .total-container {
                border-left: none;
                border-top: 1px solid #555;
                padding-left: 0;
                padding-top: 15px;
                margin-top: 15px;
                text-align: right;
            }
            .total-container .total-row {
                justify-content: flex-end;
            }
        }

        /* ---【今回追加】画面幅480px以下のためのスタイル --- */
        @media (max-width: 480px) {
            .form-horizontal-row {
                flex-direction: column; /* アビリティと条件のセクションを縦積みにする */
                align-items: stretch;   /* 幅を親要素に合わせる */
            }
        }

    /* ハンバーガーメニューのスタイル */
    .hamburger {
      cursor: pointer;
      margin-left: -5px;
      margin-right: 10px;
      user-select: none;
      color: #eee;
      display: inline-block;
    }
    
    .hamburger:hover {
      color: #2A99E6;
    }

    .side-menu {
      position: fixed;
      top: 0;
      left: -320px;
      width: 320px;
      min-height: 100vh;
      height: 100%;
      text-align: left;
      background-color: #242424;
      border-right: 1px solid #555;
      transition: left 0.3s ease;
      z-index: 1001;
      padding: 20px;
      box-sizing: border-box;
      overflow-y: auto;
      overscroll-behavior: contain;
    }

    .side-menu.open {
      left: 0;
    }

    .menu-overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      min-width: 100vw;
      min-height: 100vh;
      background-color: rgba(0, 0, 0, 0.5);
      z-index: 999;
      opacity: 0;
      visibility: hidden;
      transition: opacity 0.3s, visibility 0.3s;
    }

    .menu-overlay.open {
      opacity: 1;
      visibility: visible;
    }

    .menu-close {
      position: absolute;
      top: 20px;
      right: 20px;
      font-size: 24px;
      cursor: pointer;
      color: #eee;
      user-select: none;
    }

    .menu-close:hover {
      color: #ff6b6b;
    }

    .menu-title {
      font-size: 18px;
      font-weight: bold;
      text-align: left;
      margin-bottom: 10px;
      color: #FF6E3D;
    }

    .menu-item {
      font-size: 18px;
      text-align: left;
      display: inline-block;
      padding: 6px 0;
      color: #eee;
      text-decoration: none;
    }

    .menu-item:hover {
      color: #0CFF57;
    }

    .menu-item:last-child {
      border-bottom: none;
    }

    .menu-spacer {
      height: 30px;
    }

   .toggle-button {
      cursor: pointer;
      color: #7755FF;
      text-decoration: underline;
      font-size: 18px;
      text-align: left;
      display: block;
      padding: 6px 0;
      user-select: none;
    }

    .toggle-button:hover {
      color: #0CFF57;
      text-decoration: underline;
    }

    #linkList {
      display: none;
      color: #7755FF;
    }

    #linkList1 {
      font-size: 18px;
      text-align: left;
      padding-bottom: 6px;
      display: none;
      color: #7755FF;
    }

    #linkList2 {
      font-size: 18px;
      text-align: left;
      display: none;
      color: #7755FF;
    }

    #linkList a {
      display: inline-block;
      text-decoration: none;
      color: #7755FF;
    }

    #linkList a:visited {
      color: #7755FF;
      text-decoration: underline;
    }

    #linkList a:hover {
      text-decoration: underline;
      color: #0CFF57;
    }

    #linkList a:active {
      color: #FF0000;
      text-decoration: underline;
    }
    
    /* --- renma-armor.html風のボタンスタイル --- */

    /* 共通クラス */
    .styled-form-group {
        display: flex;
        align-items: center;
        flex-wrap: wrap; /* 条件チェックボックスが折り返せるように */
        gap: 5px 10px;   /* ボタン間の隙間 */
    }

    /* 元のラジオボタンとチェックボックスを非表示にする */
    .styled-form-group input[type="radio"],
    .styled-form-group input[type="checkbox"] {
        display: none;
    }

    /* labelをボタンのようにスタイリング */
    .styled-form-group label {
        padding: 5px 15px;
        border: 1px solid #777;
        border-radius: 20px; /* pill型デザインの角丸 */
        cursor: pointer;
        background-color: #555;
        color: white;
        transition: all 0.2s;
        margin: 0; /* 元のlabelスタイルを上書き */
    }

    /* 選択された際のスタイル(デフォルト) */
    .styled-form-group input[type="radio"]:checked + label,
    .styled-form-group input[type="checkbox"]:checked + label {
        background-color: #007bff;
        color: white;
        border-color: #007bff;
    }

    /* アビリティ選択ボタンの折り返しを禁止 */
    .form-type .styled-form-group {
        flex-wrap: nowrap;
    }

    /* --- 【今回追加したCSS】特定の条件ボタンの色を変更 --- */
    .styled-form-group input[value="HP満タン時"]:checked + label {
        background-color: forestgreen;
        border-color: forestgreen;
    }
    .styled-form-group input[value="瀕死時"]:checked + label {
        background-color: forestgreen;
        border-color: forestgreen;
    }
    .styled-form-group input[value="カウンター"]:checked + label {
        background-color: forestgreen;
        border-color: forestgreen;
    }
    .styled-form-group input[value="熱"]:checked + label {
        background-color: red;
        border-color: red;
    }
    .styled-form-group input[value="冷"]:checked + label {
        background-color: dodgerblue;
        border-color: dodgerblue;
    }
    .styled-form-group input[value="雷"]:checked + label {
        background-color: darkorange;
        border-color: darkorange;
    }
    .styled-form-group input[value="陽"]:checked + label {
        background-color: orangered;
        border-color: orangered;
    }
    .styled-form-group input[value="陰"]:checked + label {
        background-color: darkorchid;
        border-color: darkorchid;
    }

    </style>
</head>
<body>

  <div class="menu-overlay" id="menuOverlay" onclick="closeMenu()"></div>

  <div id="sidemenu-container"></div>

    <div class="main-container">
        <header>
            <h1><span class="hamburger" onclick="toggleMenu()">☰</span>練磨(防具)自動選定ツール</h1>
        </header>

        <div class="zoom-buttons">
            <button onclick="changeZoom(0.1)">＋</button>
            <button onclick="changeZoom(-0.1)">－</button>
        </div>

        <div class="file-input-container">
            <input type="file" id="json-file-input" accept=".json">
            <p id="file-status">ファイルが選択されていません</p>
        </div>

        <div class="character-grid" id="character-grid">
        </div>

        <div class="global-controls">
            <button class="calculate-button" id="calculate-all-button" disabled>全キャラクターをまとめて計算</button>
        </div>
    </div>

    <footer>
        ※使用は自己責任にて。<br>
        ※最適な組み合わせが選定出来ない可能性もあります。あくまで参考としてお考えください。<br>
        ※名将の鎧(+15)とバトルヴァンブレイス(+20)のシリーズ一致分は加味されていませんので注意してください。<br>
    </footer>

    <div class="bottom">
        <a href="renma-armor.html">リストページへ</a>　<a href="armor-top5.html">TOP5ページへ</a>
        <br>
        <a href="index.html">INDEXへ戻る</a>
    </div>

    <script>

    // サイドメニューを呼び出す関数
    function loadSideMenu() {
      fetch('sidemenu.html')
        .then(response => response.text())
        .then(data => {
          document.getElementById('sidemenu-container').innerHTML = data;

          // メニュー読み込み後に、メニュー内のトグルボタンのイベントリスナーを再設定する
          var toggleButtons = document.querySelectorAll(".toggle-button");
          toggleButtons.forEach(function(button) {
            var targetId = button.getAttribute("data-target");
            var list = document.getElementById(targetId);
            // list.style.display = "none"; // 初期状態はCSSで制御されているため不要

            button.addEventListener("click", function(){
              if (list.style.display === "block") {
                list.style.display = "none";
              } else {
                list.style.display = "block";
              }
            });
          });
        });
    }

    // ハンバーガーメニューの関数
    function toggleMenu() {
        const sideMenu = document.getElementById('sideMenu');
        if (!sideMenu) return;
        const menuOverlay = document.getElementById('menuOverlay');

        if (sideMenu.classList.contains('open')) {
            closeMenu();
        } else {
            sideMenu.classList.add('open');
            menuOverlay.classList.add('open');
        }
    }

    function closeMenu() {
        const sideMenu = document.getElementById('sideMenu');
        if (!sideMenu) return;
        const menuOverlay = document.getElementById('menuOverlay');

        sideMenu.classList.remove('open');
        menuOverlay.classList.remove('open');
    }

    // フリックでメニュー開閉（スクロール誤作動対策版）
    let startX = 0, startY = 0;
    let endX = 0, endY = 0;

    document.addEventListener('touchstart', function (e) {
      // タッチ開始時のX座標とY座標を記録
      startX = e.changedTouches[0].screenX;
      startY = e.changedTouches[0].screenY;
    }, false);

    document.addEventListener('touchend', function (e) {
      // タッチ終了時のX座標とY座標を記録
      endX = e.changedTouches[0].screenX;
      endY = e.changedTouches[0].screenY;
      handleGesture(); // ジェスチャーを判定する関数を呼び出し
    }, false);

    function handleGesture() {
      const diffX = endX - startX; // 水平方向の移動量
      const diffY = endY - startY; // 垂直方向の移動量

      // 条件1: 水平方向の移動量が、垂直方向の移動量よりも大きい場合のみ処理（スワイプかスクロールかを判定）
      if (Math.abs(diffX) > Math.abs(diffY)) {

        // 条件2-1: 右へのスワイプ（50px以上移動し、かつ画面の左端30px以内から開始）
        if (diffX > 50 && startX < 30) {
          // 右にフリックしてメニューを開く
          toggleMenu();
        } 
        // 条件2-2: 左へのスワイプ（50px以上移動）
        else if (diffX < -50) {
          // 左にフリックしてメニューを閉じる
          closeMenu();
        }
      }
      // 垂直方向の移動量が大きい場合は、何もしない（ブラウザの標準スクロールに任せる）
    }

        let zoomLevel = 1;
        function changeZoom(delta) {
            zoomLevel = (zoomLevel + delta < 0.5) ? 0.5 : (zoomLevel + delta > 2.0) ? 2.0 : zoomLevel + delta;
            document.body.style.zoom = zoomLevel;
        }
        
        function scrollToCategory(categoryId) {
            const element = document.getElementById(categoryId);
            if (element) {
                element.scrollIntoView({ behavior: 'smooth', block: 'start' });
            }
        }

    document.addEventListener('DOMContentLoaded', () => {
        let armorData = [];
        // 装備固有アビリティ(CSV)を格納するMap
        let mainNativeAbilities = new Map();
        let subNativeAbilities = new Map();

        const fileInput = document.getElementById('json-file-input');
        const fileStatus = document.getElementById('file-status');
        const characterGrid = document.getElementById('character-grid');
        const calculateAllButton = document.getElementById('calculate-all-button');

        const abilityConditions = [
            { name: "HP満タン時", value: "HP満タン時" }, { name: "瀕死時", value: "瀕死時" },
            { name: "カウンター", value: "カウンター" }, { name: "斬", value: "斬" },
            { name: "打", value: "打" }, { name: "突", value: "突" },
            { name: "熱", value: "熱" }, { name: "冷", value: "冷" },
            { name: "雷", value: "雷" }, { name: "陽", value: "陽" },
            { name: "陰", value: "陰" }
        ];

        /**
         * CSVファイルを読み込み、指定されたMapオブジェクトにデータを格納する関数
         * @param {string} url - CSVファイルのパス
         * @param {Map} targetMap - 格納先のMapオブジェクト
         */
        async function loadCsvData(url, targetMap) {
            try {
                const response = await fetch(url);
                if (!response.ok) {
                    throw new Error(`Network response was not ok for ${url}`);
                }
                const csvText = await response.text();
                const lines = csvText.trim().split('\n');
                lines.shift(); // ヘッダー行をスキップ

                lines.forEach(line => {
                    const [name, target, valueStr] = line.split(',');
                    if (name && target && valueStr) {
                        const value = parseInt(valueStr.trim(), 10);
                        if (!isNaN(value)) {
                            if (!targetMap.has(name.trim())) {
                                targetMap.set(name.trim(), []);
                            }
                            targetMap.get(name.trim()).push({ target: target.trim(), value });
                        }
                    }
                });
                console.log(`Successfully loaded and parsed: ${url}`);
            } catch (error) {
                console.error(`Error loading or parsing CSV from ${url}:`, error);
                fileStatus.innerHTML += `<br><span style="color: red;">${url} の読み込みに失敗しました。</span>`;
            }
        }
        
        /**
         * 「味方威力＋」選択時の条件を同期する関数
         * @param {number} charId - 変更が発生したキャラクターのID (1-5)
         * @param {string} eventType - 'radio-change' または 'checkbox-change'
         */
        function handleConditionSync(charId, eventType) {

            // 特別要件: キャラクター2のラジオボタンが「味方威力＋」に変更された場合
            if (charId === 2 && eventType === 'radio-change' && document.querySelector('input[name="ability-type-2"]:checked').value === '味方威力＋') {
                
                // 1. キャラクター1の条件を取得 (アビリティタイプは問わない)
                const sourceConditions = Array.from(document.querySelectorAll('input[name="condition-1"]:checked')).map(cb => cb.value);

                // 2. キャラクター2から5まで、アビリティタイプと条件を同期
                for (let i = 2; i <= 5; i++) {
                    // アビリティタイプを「味方威力＋」に設定
                    document.querySelector(`input[name="ability-type-${i}"][value="味方威力＋"]`).checked = true;
                    
                    // 条件をキャラクター1の状態に同期
                    const targetCheckboxes = document.querySelectorAll(`input[name="condition-${i}"]`);
                    targetCheckboxes.forEach(cb => {
                        cb.checked = sourceConditions.includes(cb.value);
                    });
                }
                
                // 3. 計算ボタンまでスクロール
                const calculateButton = document.getElementById('calculate-all-button');
                if (calculateButton) {
                    // ボタンが画面の中央に来るようにスクロール
                    calculateButton.scrollIntoView({ behavior: 'smooth', block: 'center' });
                }

                // この特別な処理が完了したら、以降の通常処理は行わない
                return; 
            }

            const currentAbilityType = document.querySelector(`input[name="ability-type-${charId}"]:checked`).value;

            // --- Logic for BECOMING a party buffer ---
            // If the event was a radio button change and the new type is "味方威力＋"
            if (eventType === 'radio-change' && currentAbilityType === '味方威力＋') {
                let conditionsToCopy = null;
                // Find the first previous character who is also a party buffer
                for (let i = charId - 1; i >= 1; i--) {
                    const prevAbilityType = document.querySelector(`input[name="ability-type-${i}"]:checked`).value;
                    if (prevAbilityType === '味方威力＋') {
                        // Get their conditions
                        conditionsToCopy = Array.from(document.querySelectorAll(`input[name="condition-${i}"]:checked`)).map(cb => cb.value);
                        break; // Stop at the first one
                    }
                }
                
                // If we found a previous buffer, apply their conditions to the current character
                if (conditionsToCopy !== null) {
                    const currentCheckboxes = document.querySelectorAll(`input[name="condition-${charId}"]`);
                    currentCheckboxes.forEach(cb => {
                        cb.checked = conditionsToCopy.includes(cb.value);
                    });
                }
            }

            // --- Logic for UPDATING subsequent party buffers ---
            // If the current character is a party buffer (regardless of what event happened)
            if (currentAbilityType === '味方威力＋') {
                const sourceConditions = Array.from(document.querySelectorAll(`input[name="condition-${charId}"]:checked`)).map(cb => cb.value);
                
                // Update all subsequent characters who are also party buffers
                for (let i = charId + 1; i <= 5; i++) {
                    const nextAbilityType = document.querySelector(`input[name="ability-type-${i}"]:checked`).value;
                    if (nextAbilityType === '味方威力＋') {
                        const nextCheckboxes = document.querySelectorAll(`input[name="condition-${i}"]`);
                        nextCheckboxes.forEach(cb => {
                            cb.checked = sourceConditions.includes(cb.value);
                        });
                    }
                }
            }
        }

        // ページの初期化処理
        async function initialize() {
            // キャラクターUIを生成
            for (let i = 1; i <= 5; i++) {
                const charContainer = document.createElement('div');
                charContainer.className = 'character-container';
                charContainer.id = `char-${i}`;
                
                let checkboxesHTML = '';
                abilityConditions.forEach(cond => {
                    const uniqueId = `condition-${i}-${cond.value.replace(/\s/g, '-')}`;
                    checkboxesHTML += `<input type="checkbox" name="condition-${i}" value="${cond.value}" id="${uniqueId}"><label for="${uniqueId}">${cond.name}</label>`;
                });

                charContainer.innerHTML = `
                    <h2>
                        キャラクター ${i}
                        <div class="nav-buttons">
                            <button class="nav-button" id="nav-up-${i}">▲</button>
                            <button class="nav-button" id="nav-down-${i}">▼</button>
                        </div>
                    </h2>
                    <div class="form-horizontal-row">
                        <div class="form-type">
                            <fieldset class="form-section">
                                <legend>アビリティ</legend>
                                <div class="styled-form-group">
                                    <input type="radio" name="ability-type-${i}" value="威力＋" id="ability-type-${i}-power" checked><label for="ability-type-${i}-power">威力＋</label>
                                    <input type="radio" name="ability-type-${i}" value="味方威力＋" id="ability-type-${i}-party"><label for="ability-type-${i}-party">味方威力＋</label>
                                </div>
                            </fieldset>
                        </div>
                        <div class="form-conditions">
                            <fieldset class="form-section">
                                <legend>条件 (複数可)</legend>
                                <div class="styled-form-group conditions-wrapper">${checkboxesHTML}</div>
                            </fieldset>
                        </div>
                    </div>
                    <div class="result-area" id="result-area-${i}"><p>計算結果がここに表示されます。</p></div>
                `;

                characterGrid.appendChild(charContainer);
                
                const navUpButton = charContainer.querySelector(`#nav-up-${i}`);
                const navDownButton = charContainer.querySelector(`#nav-down-${i}`);

                if (i === 1) {
                    navUpButton.disabled = true;
                } else {
                    navUpButton.addEventListener('click', () => scrollToCategory(`char-${i - 1}`));
                }

                if (i === 5) {
                    navDownButton.disabled = true;
                } else {
                    navDownButton.addEventListener('click', () => scrollToCategory(`char-${i + 1}`));
                }

                const newRadios = charContainer.querySelectorAll(`input[name="ability-type-${i}"]`);
                newRadios.forEach(radio => radio.addEventListener('change', () => handleConditionSync(i, 'radio-change')));

                const newCheckboxes = charContainer.querySelectorAll(`input[name="condition-${i}"]`);
                newCheckboxes.forEach(checkbox => checkbox.addEventListener('change', () => handleConditionSync(i, 'checkbox-change')));
            }

            // CSVデータを非同期で読み込む
            await Promise.all([
                loadCsvData('data/armor-main-ability.csv', mainNativeAbilities),
                loadCsvData('data/armor-sub-ability.csv', subNativeAbilities)
            ]);
        }
        
        // 初期化実行
        initialize();

        fileInput.addEventListener('change', (event) => {
            const file = event.target.files[0];
            if (!file) return;
            const reader = new FileReader();
            reader.onload = (e) => {
                try {
                    const rawData = JSON.parse(e.target.result);
                    armorData = rawData.map(item => ({...item, value: parseInt(item.value, 10)})).filter(item => !isNaN(item.value));
                    fileStatus.textContent = `読み込み完了: ${file.name}`;
                    fileStatus.style.color = '#98fb98';
                    calculateAllButton.disabled = false;
                } catch (error) {
                    alert('JSONファイルの読み込みまたは解析に失敗しました。\n' + error);
                    fileStatus.textContent = 'エラー: ファイルを読み込めません';
                    fileStatus.style.color = 'red';
                    armorData = [];
                    calculateAllButton.disabled = true;
                }
            };
            reader.readAsText(file);
        });
        
        function getConditionFromAbilityName(abilityName) {
            if (!abilityName) return null;
            const match = abilityName.match(/\((.*)\)/);
            return match ? match[1] : null;
        }

        /**
         * 装備の固有アビリティ(CSV)の効果値を取得する
         * @param {string} armorName - 防具名
         * @param {string} armorType - 'main' または 'sub'
         * @param {string[]} selectedConditions - キャラクターが選択した全ての条件の配列 (例: ["HP満タン時", "雷"])
         * @param {string} abilityType - '威力＋' または '味方威力＋'
         * @returns {number} - 固有アビリティの効果値の合計
         */
        function getNativeAbilityValue(armorName, armorType, selectedConditions, abilityType) {
            const nativeAbilityMap = armorType === 'main' ? mainNativeAbilities : subNativeAbilities;
            if (!nativeAbilityMap.has(armorName)) {
                return 0;
            }

            let totalValue = 0;
            const abilities = nativeAbilityMap.get(armorName);

            for (const ability of abilities) {
                const nativeAbilityTarget = ability.target;
                if (abilityType === '味方威力＋') {
                    if (nativeAbilityTarget === '味方威力') {
                        totalValue += ability.value;
                    }
                } else {
                    const isUnconditional = nativeAbilityTarget === '威力' || nativeAbilityTarget === '味方威力';
                    const isConditionMet = selectedConditions.includes(nativeAbilityTarget);
                    if (isUnconditional || isConditionMet) {
                        totalValue += ability.value;
                    }
                }
            }
            return totalValue;
        }

        /**
         * JSON値とCSV値を合算した総合値で最適な防具を見つける関数
         * @param {string} armorType - 'main' or 'sub'
         * @param {string} abilityType - '威力＋' or '味方威力＋'
         * @param {string[]} selectedConditions - 選択された条件の配列
         * @param {Set<string>} excludedItems - 既に装備済みの防具名のSet
         * @returns {object} - 最適な防具の情報 (nativeValue含む)
         */
        function findBestArmorWithNativeAbilities(armorType, abilityType, selectedConditions, excludedItems) {
            const candidates = [];

            const availableArmor = armorData.filter(item =>
                item.armorType === armorType &&
                !excludedItems.has(item.armorName)
            );

            for (const armor of availableArmor) {
                const jsonAbilityCondition = getConditionFromAbilityName(armor.abilityName);
                const jsonAbilityType = armor.abilityName.includes('味方威力＋') ? '味方威力＋' : '威力＋';
                
                if (abilityType === jsonAbilityType && selectedConditions.includes(jsonAbilityCondition)) {
                    const jsonValue = armor.value;
                    const nativeValue = getNativeAbilityValue(armor.armorName, armorType, selectedConditions, abilityType);
                    const combinedValue = jsonValue + nativeValue;

                    candidates.push({
                        ...armor,
                        combinedValue: combinedValue,
                        nativeValue: nativeValue
                    });
                }
            }

            if (candidates.length === 0) {
                return { armorName: '該当なし', value: 0, abilityName: '-', combinedValue: 0, nativeValue: 0 };
            }

            candidates.sort((a, b) => b.combinedValue - a.combinedValue);
            return candidates[0];
        }


        function calculateAllCharacters() {
            window.scrollTo({ top: 0, behavior: 'smooth' });

            const equippedItems = new Set();
            const characterResults = [];

            // フェーズ1: 各キャラクターの最適な装備を決定 (総合値で判断)
            for (let charId = 1; charId <= 5; charId++) {
                const abilityType = document.querySelector(`input[name="ability-type-${charId}"]:checked`).value;
                const selectedConditions = Array.from(document.querySelectorAll(`input[name="condition-${charId}"]:checked`)).map(cb => cb.value);
                
                let mainArmorResult = { armorName: '該当なし', value: 0, abilityName: '-', nativeValue: 0 };
                let subArmorResult = { armorName: '該当なし', value: 0, abilityName: '-', nativeValue: 0 };

                if (selectedConditions.length > 0) {
                    const bestMain = findBestArmorWithNativeAbilities('main', abilityType, selectedConditions, equippedItems);
                    if (bestMain.armorName !== '該当なし') {
                        equippedItems.add(bestMain.armorName);
                    }
                    mainArmorResult = {
                        armorName: bestMain.armorName,
                        value: bestMain.value,
                        abilityName: bestMain.abilityName,
                        nativeValue: bestMain.nativeValue
                    };

                    const bestSub = findBestArmorWithNativeAbilities('sub', abilityType, selectedConditions, equippedItems);
                    if (bestSub.armorName !== '該当なし') {
                        equippedItems.add(bestSub.armorName);
                    }
                    subArmorResult = {
                        armorName: bestSub.armorName,
                        value: bestSub.value,
                        abilityName: bestSub.abilityName,
                        nativeValue: bestSub.nativeValue
                    };
                }
                
                characterResults.push({ charId, abilityType, selectedConditions, mainArmor: mainArmorResult, subArmor: subArmorResult });
            }

            // フェーズ2: 味方威力を集計
            const partyBuffs = new Map();
            for (const result of characterResults) {
                if (result.abilityType === '味方威力＋') {
                    [result.mainArmor, result.subArmor].forEach(armor => {
                        const condition = getConditionFromAbilityName(armor.abilityName);
                        if (condition) {
                            // JSONの数値でバフ量を計算
                            partyBuffs.set(condition, (partyBuffs.get(condition) || 0) + armor.value);
                        }
                        // 固有アビリティの味方威力も加算
                         const nativeAbilityMap = armor.armorType === 'main' ? mainNativeAbilities : subNativeAbilities;
                         if (nativeAbilityMap.has(armor.armorName)) {
                             nativeAbilityMap.get(armor.armorName).forEach(ability => {
                                 if (ability.target === '味方威力') {
                                     // 味方威力は特定の条件に紐づかない全体バフとして扱う
                                     // ここでは、 selectedConditions の最初の条件に仮に紐づけるか、別途管理が必要
                                     // 簡単にするため、選択された全ての条件に均等に加算する（または、代表的なものに）
                                     result.selectedConditions.forEach(cond => {
                                         partyBuffs.set(cond, (partyBuffs.get(cond) || 0) + ability.value);
                                     });
                                 }
                             });
                         }
                    });
                }
            }

            // フェーズ3: 最終的な値を計算して表示
            for (const result of characterResults) {
                if (result.selectedConditions.length === 0) {
                    displayEmptyResult(result.charId);
                    continue;
                }

                // フェーズ1で計算済みの固有アビリティ値を使用
                const mainNativeValue = result.mainArmor.nativeValue || 0;
                const subNativeValue = result.subArmor.nativeValue || 0;
                
                const totalNativeValue = mainNativeValue + subNativeValue;
                const selfJsonValue = result.mainArmor.value + result.subArmor.value;

                let totals;
                if (result.abilityType === '威力＋') {
                    let partyValue = 0;
                    result.selectedConditions.forEach(condition => {
                        partyValue += partyBuffs.get(condition) || 0;
                    });
                    totals = {
                        self: selfJsonValue + totalNativeValue,
                        party: partyValue,
                        grand: selfJsonValue + totalNativeValue + partyValue
                    };
                } else { // 味方威力＋の場合
                    totals = { 
                        self: selfJsonValue + totalNativeValue
                    };
                }
                displayResult(result.charId, result.mainArmor, result.subArmor, totals, mainNativeValue, subNativeValue);
            }
        }
        
        function displayResult(charId, mainArmor, subArmor, totals, mainNativeValue, subNativeValue) {
            const resultArea = document.getElementById(`result-area-${charId}`);
            
            let mainArmorNameStyle = '';
            if (mainArmor.armorName === '該当なし') {
                mainArmorNameStyle = 'style="color: red;"';
            } else if (mainArmor.armorName.includes('名将の鎧') || mainArmor.armorName.includes('ﾊﾞﾄﾙｳﾞｧﾝﾌﾞﾚｲｽ')) {
                mainArmorNameStyle = 'style="color: magenta;"';
            } else if (mainNativeValue > 0) {
                mainArmorNameStyle = 'style="color: orange;"';
            }
            const mainArmorNameText = mainNativeValue > 0 && mainArmor.armorName !== '該当なし' ? `${mainArmor.armorName}(+${mainNativeValue})` : mainArmor.armorName;
            
            let subArmorNameStyle = '';
             if (subArmor.armorName === '該当なし') {
                subArmorNameStyle = 'style="color: red;"';
            } else if (subArmor.armorName.includes('名将の鎧') || subArmor.armorName.includes('ﾊﾞﾄﾙｳﾞｧﾝﾌﾞﾚｲｽ')) {
                subArmorNameStyle = 'style="color: magenta;"';
            } else if (subNativeValue > 0) {
                subArmorNameStyle = 'style="color: orange;"';
            }
            const subArmorNameText = subNativeValue > 0 && subArmor.armorName !== '該当なし' ? `${subArmor.armorName}(+${subNativeValue})` : subArmor.armorName;

            let totalHTML = '';
            if (totals.grand !== undefined) {
                totalHTML = `
                    <div class="total-container">
                        <div class="total-row"><span class="label">自身:</span><span class="value">${totals.self}%</span></div>
                        <div class="total-row"><span class="label">味方:</span><span class="value">${totals.party}%</span></div>
                        <div class="total-row final-total"><span class="label">合計:</span><span class="value">${totals.grand}%</span></div>
                    </div>
                `;
            } else {
                totalHTML = `
                    <div class="total-container">
                        <div class="total-row final-total"><span class="label">合計:</span><span class="value">${totals.self}%</span></div>
                    </div>
                `;
            }

            resultArea.innerHTML = `
                <div class="result-details">
                    <table class="result-table">
                        <tbody>
                            <tr>
                                <td class="col-heading"><span class="heading-text">主防具</span></td>
                                <td class="col-armor">
                                    <span class="data-label">装備:</span><span class="armor-text" ${mainArmorNameStyle}>${mainArmorNameText}</span>
                                </td>
                                <td class="col-ability">
                                    <span class="data-label">アビリティ:</span><span class="ability-text">${mainArmor.abilityName}</span>
                                </td>
                                <td class="col-value">
                                    <span class="data-label">効果値:</span><span class="value-text">${mainArmor.value}%</span>
                                </td>
                            </tr>
                            <tr>
                                <td class="col-heading"><span class="heading-text">副防具</span></td>
                                <td class="col-armor">
                                    <span class="data-label">装備:</span><span class="armor-text" ${subArmorNameStyle}>${subArmorNameText}</span>
                                </td>
                                <td class="col-ability">
                                    <span class="data-label">アビリティ:</span><span class="ability-text">${subArmor.abilityName}</span>
                                </td>
                                <td class="col-value">
                                    <span class="data-label">効果値:</span><span class="value-text">${subArmor.value}%</span>
                                </td>
                            </tr>
                        </tbody>
                    </table>
                </div>
                ${totalHTML}
            `;
        }

        function displayEmptyResult(charId) {
            const resultArea = document.getElementById(`result-area-${charId}`);
            resultArea.innerHTML = `<p>条件を選択して計算を実行してください。</p>`;
        }

        calculateAllButton.addEventListener('click', calculateAllCharacters);
    });

    // ページをリロードしたらサイドメニューを呼び出す
    window.onload = function () {
        loadSideMenu();
    }

  </script>

</body>
</html>